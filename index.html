<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>过马路小游戏 - H5纯净版</title>
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            background: #333; 
            overflow: hidden; 
            font-family: 'Microsoft YaHei', sans-serif; 
            touch-action: none; /* 防止浏览器缩放/滚动 */
        }
        #gameCanvas { 
            display: block; 
            margin: 0 auto; 
        }
        #ui-layer { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            pointer-events: none; 
        }
        .score { 
            position: absolute; 
            top: 20px; 
            left: 20px; 
            color: white; 
            font-size: 24px; 
            font-weight: bold; 
            text-shadow: 2px 2px 0 #000; 
        }
        .game-over { 
            display: none; 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            text-align: center; 
            background: rgba(0,0,0,0.85); 
            padding: 30px; 
            border-radius: 15px; 
            pointer-events: auto; 
            border: 2px solid #fff;
        }
        .game-over h1 { 
            color: white; 
            margin: 0 0 20px; 
            font-size: 32px;
        }
        .game-over p {
            color: #ccc;
            margin-bottom: 20px;
        }
        .btn { 
            background: #ff4444; 
            color: white; 
            border: none; 
            padding: 12px 30px; 
            font-size: 20px; 
            border-radius: 8px; 
            cursor: pointer; 
            transition: background 0.2s;
        }
        .btn:hover { background: #ff6666; }
        
        /* 屏幕上的控制按钮 */
        .controls { 
            position: absolute; 
            bottom: 30px; 
            width: 100%; 
            display: flex; 
            justify-content: center; 
            gap: 15px; 
            pointer-events: auto; 
        }
        .d-pad {
            display: grid;
            grid-template-columns: repeat(3, 60px);
            grid-template-rows: repeat(2, 60px);
            gap: 5px;
            align-items: center;
            justify-items: center;
        }
        .control-btn { 
            width: 60px; 
            height: 60px; 
            background: rgba(255,255,255,0.2); 
            border: 2px solid rgba(255,255,255,0.5); 
            border-radius: 12px; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            color: white; 
            font-size: 28px; 
            user-select: none; 
            cursor: pointer;
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
        }
        .control-btn:active { 
            background: rgba(255,255,255,0.5); 
            transform: scale(0.95);
        }
        .control-btn.up { grid-column: 2; grid-row: 1; }
        .control-btn.left { grid-column: 1; grid-row: 2; }
        .control-btn.down { grid-column: 2; grid-row: 2; }
        .control-btn.right { grid-column: 3; grid-row: 2; }

    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-layer">
        <div class="score">分数: <span id="scoreVal">0</span></div>
        
        <div id="gameOver" class="game-over">
            <h1>游戏结束</h1>
            <p>最终得分: <span id="finalScore">0</span></p>
            <button class="btn" onclick="resetGame()">下辈子再见</button>
        </div>

        <div class="controls" id="touchControls">
            <div class="d-pad">
                <div class="control-btn up" data-dir="up">↑</div>
                <div class="control-btn left" data-dir="left">←</div>
                <div class="control-btn down" data-dir="down">↓</div>
                <div class="control-btn right" data-dir="right">→</div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // 游戏状态
        let isGameOver = false;
        let score = 0;
        let maxScore = 0;
        let lanes = [];
        let player = {
            gridX: 0,
            gridY: 0, // 相对于当前视图
            x: 0,
            y: 0,
            progress: 0 // 动画
        };
        
        // 配置
        const GRID_SIZE = 50;
        const GRID_COLS = 9; // 奇数保持中心对齐
        let CANVAS_WIDTH, CANVAS_HEIGHT;
        let cameraY = 0;
        
        // 资源 / 样式
        const COLORS = {
            grass: '#8bc34a',
            road: '#555',
            water: '#03a9f4',
            car: ['#f44336', '#ffeb3b', '#9c27b0'],
            log: '#795548',
            chicken: '#fff'
        };

        // 输入处理
        let keys = {};
        
        function resize() {
            CANVAS_WIDTH = window.innerWidth;
            CANVAS_HEIGHT = window.innerHeight;
            canvas.width = CANVAS_WIDTH;
            canvas.height = CANVAS_HEIGHT;
        }
        window.addEventListener('resize', resize);
        resize();

        // 类
        class Lane {
            constructor(gridY) {
                this.gridY = gridY;
                this.type = this.getType(gridY);
                this.obstacles = [];
                this.speed = (Math.random() * 2 + 1) * (Math.random() < 0.5 ? 1 : -1);
                this.setupObstacles();
            }

            getType(y) {
                if (y < 3) return 'grass'; // 起始区域
                const r = Math.random();
                if (r < 0.3) return 'grass';
                if (r < 0.8) return 'road';
                return 'water';
            }
            
            setupObstacles() {
                if (this.type === 'road') {
                    // 添加汽车
                    let count = Math.floor(Math.random() * 2) + 1;
                    for(let i=0; i<count; i++) {
                        this.obstacles.push({
                            x: Math.random() * GRID_COLS * GRID_SIZE,
                            width: GRID_SIZE * (Math.random() < 0.3 ? 2 : 1.2), // 卡车 vs 汽车
                            color: COLORS.car[Math.floor(Math.random() * COLORS.car.length)]
                        });
                    }
                } else if (this.type === 'grass') {
                    // 添加树木（静态障碍物）
                    let count = Math.floor(Math.random() * 3);
                    for(let i=0; i<count; i++) {
                        // 对齐到网格
                        let col = Math.floor(Math.random() * GRID_COLS);
                        // 不阻挡起始中心位置
                        if(this.gridY === 0 && col === Math.floor(GRID_COLS/2)) continue;
                        
                        this.obstacles.push({
                            col: col,
                            x: col * GRID_SIZE, 
                            width: GRID_SIZE,
                            isTree: true
                        });
                    }
                }
            }

            update(dt) {
                if (this.type === 'road') {
                    this.obstacles.forEach(obs => {
                        obs.x += this.speed;
                        const laneWidth = GRID_COLS * GRID_SIZE;
                        if (this.speed > 0 && obs.x > laneWidth) obs.x = -obs.width;
                        if (this.speed < 0 && obs.x < -obs.width) obs.x = laneWidth;
                    });
                }
            }

            draw(ctx, yPos) {
                // 绘制地面
                ctx.fillStyle = (this.type === 'road') ? COLORS.road : COLORS.grass;
                ctx.fillRect(0, yPos, CANVAS_WIDTH, GRID_SIZE);

                // 为道路绘制条纹
                if (this.type === 'road') {
                    ctx.strokeStyle = '#fff';
                    ctx.setLineDash([10, 10]);
                    ctx.beginPath();
                    ctx.moveTo(0, yPos + 2);
                    ctx.lineTo(CANVAS_WIDTH, yPos + 2);
                    ctx.moveTo(0, yPos + GRID_SIZE - 2);
                    ctx.lineTo(CANVAS_WIDTH, yPos + GRID_SIZE - 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                // 中心偏移对齐游戏网格
                const gridOffsetX = (CANVAS_WIDTH - GRID_COLS * GRID_SIZE) / 2;

                // 绘制障碍物
                this.obstacles.forEach(obs => {
                    let drawX = gridOffsetX + obs.x;
                    
                    if (obs.isTree) {
                        // 树
                        drawX = gridOffsetX + obs.col * GRID_SIZE;
                        ctx.fillStyle = '#388E3C'; // 深绿色
                        ctx.fillRect(drawX + 5, yPos + 5, GRID_SIZE - 10, GRID_SIZE - 10);
                        // 细节
                        ctx.fillStyle = '#1B5E20';
                        ctx.fillRect(drawX + 10, yPos + 10, GRID_SIZE - 20, GRID_SIZE - 20);
                    } else {
                        // 汽车
                        ctx.fillStyle = obs.color;
                        ctx.fillRect(drawX, yPos + 8, obs.width, GRID_SIZE - 16);
                        // 细节简化
                        ctx.fillStyle = 'rgba(0,0,0,0.3)';
                        ctx.fillRect(drawX + 5, yPos + 5, 5, 5); // 车轮
                        ctx.fillRect(drawX + obs.width - 10, yPos + 5, 5, 5); // 车轮
                    }
                });
            }

            checkCollision(pX, pY) {
                if (this.gridY !== pY) return false;

                const gridOffsetX = (CANVAS_WIDTH - GRID_COLS * GRID_SIZE) / 2;
                const pWorldX = gridOffsetX + pX * GRID_SIZE + 10;
                const pWidth = GRID_SIZE - 20;

                for(let obs of this.obstacles) {
                    if (obs.isTree) {
                        if (obs.col === pX) return true;
                    } else {
                        // 汽车碰撞
                        let obsWorldX = gridOffsetX + obs.x;
                        if (pWorldX < obsWorldX + obs.width &&
                            pWorldX + pWidth > obsWorldX) {
                            return true;
                        }
                    }
                }
                return false;
            }
        }

        // 逻辑
        function init() {
            isGameOver = false;
            score = 0;
            cameraY = 0;
            document.getElementById('scoreVal').innerText = score;
            document.getElementById('gameOver').style.display = 'none';
            
            player.gridX = Math.floor(GRID_COLS / 2);
            player.gridY = 0;
            
            lanes = [];
            // 生成初始车道
            for(let i=0; i<20; i++) {
                lanes.push(new Lane(i));
            }
        }

        function canMoveTo(gx, gy) {
            // 检查边界
            if (gx < 0 || gx >= GRID_COLS) return false;
            // 检查树木
            ensureLane(gy);
            const lane = lanes.find(l => l.gridY === gy);
            if (lane) {
                if (lane.obstacles.some(o => o.isTree && o.col === gx)) return false;
            }
            return true;
        }

        function ensureLane(y) {
            while(lanes[lanes.length-1].gridY < y + 10) {
                lanes.push(new Lane(lanes[lanes.length-1].gridY + 1));
            }
        }

        function move(dx, dy) {
            if (isGameOver) return;
            
            const targetX = player.gridX + dx;
            const targetY = player.gridY + dy;
            
            if (targetY < player.gridY - 1) return; // 不能后退太多

            if (canMoveTo(targetX, targetY)) {
                player.gridX = targetX;
                player.gridY = targetY;
                
                // 分数更新
                if (player.gridY > score) {
                    score = player.gridY;
                    document.getElementById('scoreVal').innerText = score;
                    ensureLane(score);
                }
            }
        }

        function update() {
            if (isGameOver) return;
            
            const activeLanes = lanes.filter(l => l.gridY >= player.gridY - 5 && l.gridY <= player.gridY + 15);
            activeLanes.forEach(l => l.update());

            // 检查碰撞
            const currentLane = lanes.find(l => l.gridY === player.gridY);
            if (currentLane && currentLane.checkCollision(player.gridX, player.gridY)) {
                gameOver();
            }

            // 平滑相机
            const targetCamY = (player.gridY * GRID_SIZE) - (CANVAS_HEIGHT / 2) + (GRID_SIZE * 2);
            cameraY += (targetCamY - cameraY) * 0.1;
        }

        function draw() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            const PlayerScreenY = CANVAS_HEIGHT * 0.6; 
            const baseOffset = PlayerScreenY + (player.gridY * GRID_SIZE); 
            
            // 绘制车道
            lanes.forEach(lane => {
                const worldY = lane.gridY * GRID_SIZE;
                const screenY = PlayerScreenY - (worldY - cameraY);
                
                if (screenY > -GRID_SIZE && screenY < CANVAS_HEIGHT) {
                    lane.draw(ctx, screenY);
                }
            });

            // 绘制玩家
            const gridOffsetX = (CANVAS_WIDTH - GRID_COLS * GRID_SIZE) / 2;
            const px = gridOffsetX + player.gridX * GRID_SIZE;
            const py = PlayerScreenY - (player.gridY * GRID_SIZE - cameraY);
            
            ctx.fillStyle = COLORS.chicken;
            ctx.fillRect(px + 10, py + 10, GRID_SIZE - 20, GRID_SIZE - 20);
            
            // 喙
            ctx.fillStyle = 'orange';
            ctx.fillRect(px + GRID_SIZE/2 - 5, py + 5, 10, 5);
            
            // 眼睛
            ctx.fillStyle = 'black';
            ctx.fillRect(px + 15, py + 15, 5, 5);
            ctx.fillRect(px + GRID_SIZE - 20, py + 15, 5, 5);
        }

        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }

        function gameOver() {
            isGameOver = true;
            document.getElementById('finalScore').innerText = score;
            document.getElementById('gameOver').style.display = 'block';
        }

        function resetGame() {
            init();
        }

        // 输入
        window.addEventListener('keydown', e => {
            if (e.key === 'ArrowUp') move(0, 1);
            else if (e.key === 'ArrowDown') move(0, -1);
            else if (e.key === 'ArrowLeft') move(-1, 0);
            else if (e.key === 'ArrowRight') move(1, 0);
            
            // 防止滚动
            if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) e.preventDefault();
        });

        // 触摸
        document.querySelectorAll('.control-btn').forEach(btn => {
            btn.addEventListener('pointerdown', (e) => {
                e.preventDefault(); // 防止选择
                const dir = btn.dataset.dir;
                if (dir === 'up') move(0, 1);
                if (dir === 'down') move(0, -1);
                if (dir === 'left') move(-1, 0);
                if (dir === 'right') move(1, 0);
            });
        });

        // 开始
        init();
        loop();
    </script>
</body>
</html>
