<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>过马路小游戏 - H5纯净版</title>
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            background: #333; 
            overflow: hidden; 
            font-family: 'Microsoft YaHei', sans-serif; 
            touch-action: none; /* Prevent browser zooming/scrolling */
        }
        #gameCanvas { 
            display: block; 
            margin: 0 auto; 
        }
        #ui-layer { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            pointer-events: none; 
        }
        .score { 
            position: absolute; 
            top: 20px; 
            left: 20px; 
            color: white; 
            font-size: 24px; 
            font-weight: bold; 
            text-shadow: 2px 2px 0 #000; 
        }
        .game-over { 
            display: none; 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            text-align: center; 
            background: rgba(0,0,0,0.85); 
            padding: 30px; 
            border-radius: 15px; 
            pointer-events: auto; 
            border: 2px solid #fff;
        }
        .game-over h1 { 
            color: white; 
            margin: 0 0 20px; 
            font-size: 32px;
        }
        .game-over p {
            color: #ccc;
            margin-bottom: 20px;
        }
        .btn { 
            background: #ff4444; 
            color: white; 
            border: none; 
            padding: 12px 30px; 
            font-size: 20px; 
            border-radius: 8px; 
            cursor: pointer; 
            transition: background 0.2s;
        }
        .btn:hover { background: #ff6666; }
        
        /* On-screen controls */
        .controls { 
            position: absolute; 
            bottom: 30px; 
            width: 100%; 
            display: flex; 
            justify-content: center; 
            gap: 15px; 
            pointer-events: auto; 
        }
        .d-pad {
            display: grid;
            grid-template-columns: repeat(3, 60px);
            grid-template-rows: repeat(2, 60px);
            gap: 5px;
            align-items: center;
            justify-items: center;
        }
        .control-btn { 
            width: 60px; 
            height: 60px; 
            background: rgba(255,255,255,0.2); 
            border: 2px solid rgba(255,255,255,0.5); 
            border-radius: 12px; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            color: white; 
            font-size: 28px; 
            user-select: none; 
            cursor: pointer;
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
        }
        .control-btn:active { 
            background: rgba(255,255,255,0.5); 
            transform: scale(0.95);
        }
        .control-btn.up { grid-column: 2; grid-row: 1; }
        .control-btn.left { grid-column: 1; grid-row: 2; }
        .control-btn.down { grid-column: 2; grid-row: 2; }
        .control-btn.right { grid-column: 3; grid-row: 2; }

    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-layer">
        <div class="score">分数: <span id="scoreVal">0</span></div>
        
        <div id="gameOver" class="game-over">
            <h1>游戏结束</h1>
            <p>最终得分: <span id="finalScore">0</span></p>
            <button class="btn" onclick="resetGame()">下辈子再见</button>
        </div>

        <div class="controls" id="touchControls">
            <div class="d-pad">
                <div class="control-btn up" data-dir="up">↑</div>
                <div class="control-btn left" data-dir="left">←</div>
                <div class="control-btn down" data-dir="down">↓</div>
                <div class="control-btn right" data-dir="right">→</div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game State
        let isGameOver = false;
        let score = 0;
        let maxScore = 0;
        let lanes = [];
        let player = {
            gridX: 0,
            gridY: 0, // relative to current view
            x: 0,
            y: 0,
            progress: 0 // animation
        };
        
        // Configuration
        const GRID_SIZE = 50;
        const GRID_COLS = 9; // Odd number keeps center aligned
        let CANVAS_WIDTH, CANVAS_HEIGHT;
        let cameraY = 0;
        
        // Assets / Styles
        const COLORS = {
            grass: '#8bc34a',
            road: '#555',
            water: '#03a9f4',
            car: ['#f44336', '#ffeb3b', '#9c27b0'],
            log: '#795548',
            chicken: '#fff'
        };

        // Input handling
        let keys = {};
        
        function resize() {
            CANVAS_WIDTH = window.innerWidth;
            CANVAS_HEIGHT = window.innerHeight;
            canvas.width = CANVAS_WIDTH;
            canvas.height = CANVAS_HEIGHT;
            // Recenter player visually if needed (not affecting logic)
        }
        window.addEventListener('resize', resize);
        resize();

        // Classes
        class Lane {
            constructor(gridY) {
                this.gridY = gridY;
                this.type = this.getType(gridY);
                this.obstacles = [];
                this.speed = (Math.random() * 2 + 1) * (Math.random() < 0.5 ? 1 : -1);
                this.setupObstacles();
            }

            getType(y) {
                if (y < 3) return 'grass'; // Start area
                const r = Math.random();
                if (r < 0.3) return 'grass';
                if (r < 0.8) return 'road';
                return 'water'; // Simple implementation: no water for now to keep it "Pure H5" simpler, sticking to road/grass like original prompt ref. Or add water if we have logs.
                // The original Three.js code had cars, trucks, forest (grass with trees). No water. Let's stick to that.
            }
            // For this simpler version, let's stick to Road and Grass to match the original reference provided.
            // Original: field/grass, forest(with trees), car, truck.
            
            setupObstacles() {
                if (this.type === 'road') {
                    // Add cars
                    let count = Math.floor(Math.random() * 2) + 1;
                    for(let i=0; i<count; i++) {
                        this.obstacles.push({
                            x: Math.random() * GRID_COLS * GRID_SIZE,
                            width: GRID_SIZE * (Math.random() < 0.3 ? 2 : 1.2), // Truck vs Car
                            color: COLORS.car[Math.floor(Math.random() * COLORS.car.length)]
                        });
                    }
                } else if (this.type === 'grass') {
                    // Add trees (static obstacles)
                    let count = Math.floor(Math.random() * 3);
                    for(let i=0; i<count; i++) {
                        // Align to grid
                        let col = Math.floor(Math.random() * GRID_COLS);
                        // Don't block the very center on start
                        if(this.gridY === 0 && col === Math.floor(GRID_COLS/2)) continue;
                        
                        this.obstacles.push({
                            col: col,
                            x: col * GRID_SIZE, 
                            width: GRID_SIZE,
                            isTree: true
                        });
                    }
                }
            }

            update(dt) {
                if (this.type === 'road') {
                    this.obstacles.forEach(obs => {
                        obs.x += this.speed;
                        const laneWidth = GRID_COLS * GRID_SIZE;
                        if (this.speed > 0 && obs.x > laneWidth) obs.x = -obs.width;
                        if (this.speed < 0 && obs.x < -obs.width) obs.x = laneWidth;
                    });
                }
            }

            draw(ctx, yPos) {
                // Determine lane width to draw (full screen width)
                
                // Draw ground
                ctx.fillStyle = (this.type === 'road') ? COLORS.road : COLORS.grass;
                ctx.fillRect(0, yPos, CANVAS_WIDTH, GRID_SIZE);

                // Draw Stripes for road
                if (this.type === 'road') {
                    ctx.strokeStyle = '#fff';
                    ctx.setLineDash([10, 10]);
                    ctx.beginPath();
                    ctx.moveTo(0, yPos + 2);
                    ctx.lineTo(CANVAS_WIDTH, yPos + 2);
                    ctx.moveTo(0, yPos + GRID_SIZE - 2);
                    ctx.lineTo(CANVAS_WIDTH, yPos + GRID_SIZE - 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                // Center offset to align the "game grid" to the center of the screen
                const gridOffsetX = (CANVAS_WIDTH - GRID_COLS * GRID_SIZE) / 2;

                // Draw obstacles
                this.obstacles.forEach(obs => {
                    let drawX = gridOffsetX + obs.x;
                    
                    if (obs.isTree) {
                        // Tree
                        drawX = gridOffsetX + obs.col * GRID_SIZE;
                        ctx.fillStyle = '#388E3C'; // Dark Green
                        ctx.fillRect(drawX + 5, yPos + 5, GRID_SIZE - 10, GRID_SIZE - 10);
                        // Detail
                        ctx.fillStyle = '#1B5E20';
                        ctx.fillRect(drawX + 10, yPos + 10, GRID_SIZE - 20, GRID_SIZE - 20);
                    } else {
                        // Car
                        ctx.fillStyle = obs.color;
                        ctx.fillRect(drawX, yPos + 8, obs.width, GRID_SIZE - 16);
                        // Details (lights/wheels) simplified
                        ctx.fillStyle = 'rgba(0,0,0,0.3)';
                        ctx.fillRect(drawX + 5, yPos + 5, 5, 5); // Wheel
                        ctx.fillRect(drawX + obs.width - 10, yPos + 5, 5, 5); // Wheel
                    }
                });
            }

            checkCollision(pX, pY) {
                // pX is grid column. pY is this lane's gridY
                // Player is approximately at grid center
                if (this.gridY !== pY) return false;

                const gridOffsetX = (CANVAS_WIDTH - GRID_COLS * GRID_SIZE) / 2;
                
                // Player hitbox (world space)
                const pWorldX = gridOffsetX + pX * GRID_SIZE + 10;
                const pWidth = GRID_SIZE - 20;

                for(let obs of this.obstacles) {
                    if (obs.isTree) {
                        // Tree collision is checked before movement usually (grid based), 
                        // but let's double check here or just rely on move logic
                        if (obs.col === pX) return true;
                    } else {
                        // Car collision (continuous)
                        let obsWorldX = gridOffsetX + obs.x;
                        if (pWorldX < obsWorldX + obs.width &&
                            pWorldX + pWidth > obsWorldX) {
                            return true;
                        }
                    }
                }
                return false;
            }
        }

        // Logic
        function init() {
            isGameOver = false;
            score = 0;
            cameraY = 0;
            document.getElementById('scoreVal').innerText = score;
            document.getElementById('gameOver').style.display = 'none';
            
            player.gridX = Math.floor(GRID_COLS / 2);
            player.gridY = 0;
            
            lanes = [];
            // Generate initial lanes
            for(let i=0; i<20; i++) {
                lanes.push(new Lane(i));
            }
        }

        function canMoveTo(gx, gy) {
            // Check boundaries
            if (gx < 0 || gx >= GRID_COLS) return false;
            // Check trees
            // Ideally we need to find the lane corresponding to gy
            // But since lanes are generated dynamically, we need to ensure we have it
            ensureLane(gy);
            const lane = lanes.find(l => l.gridY === gy);
            if (lane) {
                if (lane.obstacles.some(o => o.isTree && o.col === gx)) return false;
            }
            return true;
        }

        function ensureLane(y) {
            while(lanes[lanes.length-1].gridY < y + 10) {
                lanes.push(new Lane(lanes[lanes.length-1].gridY + 1));
            }
        }

        function move(dx, dy) {
            if (isGameOver) return;
            
            const targetX = player.gridX + dx;
            const targetY = player.gridY + dy;
            
            if (targetY < player.gridY - 1) return; // Can't go back too much

            if (canMoveTo(targetX, targetY)) {
                
                // Visual jump effect could be added here
                player.gridX = targetX;
                player.gridY = targetY;
                
                // Score update
                if (player.gridY > score) {
                    score = player.gridY;
                    document.getElementById('scoreVal').innerText = score;
                    ensureLane(score);
                }
            }
        }

        function update() {
            if (isGameOver) return;
            
            // Clean up old lanes
            if (lanes.length > 30) {
                 // Keep lanes around player
            }
            const activeLanes = lanes.filter(l => l.gridY >= player.gridY - 5 && l.gridY <= player.gridY + 15);
            activeLanes.forEach(l => l.update());

            // Check collision
            const currentLane = lanes.find(l => l.gridY === player.gridY);
            if (currentLane && currentLane.checkCollision(player.gridX, player.gridY)) {
                gameOver();
            }

            // Smooth camera
            const targetCamY = (player.gridY * GRID_SIZE) - (CANVAS_HEIGHT / 2) + (GRID_SIZE * 2);
            cameraY += (targetCamY - cameraY) * 0.1;
        }

        function draw() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            // Draw lanes
            // We need to translate world y to screen y
            // world y = lane.gridY * GRID_SIZE
            // screen y = CANVAS_HEIGHT - (worldY - cameraY) --- assuming camera moves up
            // Let's coordinate system: 
            // Y increases upwards in game logic (0, 1, 2...)
            // Screen Y increases downwards.
            // So worldY 0 is at bottom of screen?
            // Let's standardise: 
            // Screen Draw Y = (CANVAS_HEIGHT - 100) - (lane.gridY * GRID_SIZE) + cameraY 
            // This effectively moves the world down as cameraY (player Y) increases? 
            // No, if player goes up (gridY inc), we want world to move down.
            // Screen Y = Offset - (lane.gridY * GRID_SIZE) + (cameraY scaled)
            
            // Let's center player vertically roughly
            // Player Screen Y = Constant
            
            const PlayerScreenY = CANVAS_HEIGHT * 0.6; 
            // When player.gridY increases, the lane.gridY should map to a higher visual position (lower Screen Y value/Upwards)
            // wait, Top Down 2D usually Y increases Downwards. But we said "Forward" increases Y.
            // unique approach: Forward = Up visual = Decreasing Screen Y.
            
            const baseOffset = PlayerScreenY + (player.gridY * GRID_SIZE); 
            
            // Draw visible lanes
            lanes.forEach(lane => {
                // Screen Y for this lane
                // layout: gridY=0 is bottom, gridY=1 is above it.
                // screenY = PlayerScreenY + (player.gridY - lane.gridY) * GRID_SIZE
                
                // Smooth camera: use cameraY instead of player.gridY * GRID_SIZE
                // cameraY approximates player.gridY * GRID_SIZE
                
                // Let's use cameraY which tracks player world Y
                // World Y of lane = lane.gridY * GRID_SIZE
                // Render Y = PlayerScreenY - (World Y - cameraY)
                // Wait... if WorldY > CameraY, it should be above (Screen Y smaller)
                
                const worldY = lane.gridY * GRID_SIZE;
                // We track cameraY as (player.gridY * GRID_SIZE)
                
                const screenY = PlayerScreenY - (worldY - cameraY);
                
                if (screenY > -GRID_SIZE && screenY < CANVAS_HEIGHT) {
                    lane.draw(ctx, screenY);
                }
            });

            // Draw Player
            // Player X is centered grid
            const gridOffsetX = (CANVAS_WIDTH - GRID_COLS * GRID_SIZE) / 2;
            const px = gridOffsetX + player.gridX * GRID_SIZE;
            
            // Player Y is calculated same as lane
            // But we want smooth movement if we had it. For now grid snap:
            // logic Y = player.gridY * GRID_SIZE
            const py = PlayerScreenY - (player.gridY * GRID_SIZE - cameraY);
            
            ctx.fillStyle = COLORS.chicken;
            ctx.fillRect(px + 10, py + 10, GRID_SIZE - 20, GRID_SIZE - 20);
            
            // Beak
            ctx.fillStyle = 'orange';
            ctx.fillRect(px + GRID_SIZE/2 - 5, py + 5, 10, 5);
            
            // Eyes
            ctx.fillStyle = 'black';
            ctx.fillRect(px + 15, py + 15, 5, 5);
            ctx.fillRect(px + GRID_SIZE - 20, py + 15, 5, 5);
        }

        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }

        function gameOver() {
            isGameOver = true;
            document.getElementById('finalScore').innerText = score;
            document.getElementById('gameOver').style.display = 'block';
        }

        function resetGame() {
            init();
        }

        // Input
        window.addEventListener('keydown', e => {
            if (e.key === 'ArrowUp') move(0, 1);
            else if (e.key === 'ArrowDown') move(0, -1);
            else if (e.key === 'ArrowLeft') move(-1, 0);
            else if (e.key === 'ArrowRight') move(1, 0);
            
            // Prevent scrolling
            if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) e.preventDefault();
        });

        // Touch
        document.querySelectorAll('.control-btn').forEach(btn => {
            btn.addEventListener('pointerdown', (e) => {
                e.preventDefault(); // prevent selection
                const dir = btn.dataset.dir;
                if (dir === 'up') move(0, 1);
                if (dir === 'down') move(0, -1);
                if (dir === 'left') move(-1, 0);
                if (dir === 'right') move(1, 0);
            });
        });

        // Start
        init();
        loop();
    </script>
</body>
</html>